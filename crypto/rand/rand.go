package rand

import (
	"crypto/rand"
	"io"
	"math/big"

	"github.com/alexfalkowski/go-service/v2/bytes"
	"github.com/alexfalkowski/go-service/v2/strings"
)

const letters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

// NewReader returns a cryptographically secure random Reader.
//
// This is a thin wrapper around crypto/rand.Reader.
func NewReader() Reader {
	return rand.Reader
}

// Reader is a cryptographically secure random source.
//
// It is defined as an aliasable type so it can be injected/mocked in tests while still behaving like
// an io.Reader.
type Reader io.Reader

// NewGenerator constructs a Generator that draws randomness from reader.
//
// The provided reader should be cryptographically secure (for example the value returned by NewReader).
func NewGenerator(reader Reader) *Generator {
	return &Generator{reader: reader}
}

// Generator produces cryptographically secure random values.
//
// It provides both raw byte reads (via Read) and convenience helpers for generating random text/byte
// sequences drawn from a fixed character set.
type Generator struct {
	reader Reader
}

// Read fills b with random bytes read from the underlying Reader.
//
// It reads exactly len(b) bytes or returns an error.
func (g *Generator) Read(b []byte) (int, error) {
	return io.ReadFull(g.reader, b)
}

// GenerateBytes returns a cryptographically random byte slice of length size.
//
// The bytes are generated by selecting random characters from the package's letter set and converting
// the resulting string to bytes. The returned slice contains only characters from that set.
//
// Note: if you need uniformly random bytes across the full 0-255 range, use Read instead.
func (g *Generator) GenerateBytes(size int) ([]byte, error) {
	s, err := g.generate(size, letters)
	return strings.Bytes(s), err
}

// GenerateText returns a cryptographically random string of length size.
//
// Characters are drawn from the package's letter set.
func (g *Generator) GenerateText(size int) (string, error) {
	return g.generate(size, letters)
}

func (g *Generator) generate(size int, values string) (string, error) {
	data := make([]byte, size)
	length := int64(len(values))

	for i := range size {
		num, err := rand.Int(g.reader, big.NewInt(length))
		if err != nil {
			return strings.Empty, err
		}

		data[i] = values[num.Int64()]
	}

	return bytes.String(data), nil
}
